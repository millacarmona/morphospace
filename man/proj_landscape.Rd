% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mspace_workflow.R
\name{proj_landscape}
\alias{proj_landscape}
\title{Project landscape into morphospace}
\usage{
proj_landscape(
  mspace,
  FUN = NULL,
  X = NULL,
  method = "interp",
  palette = heat.colors,
  ncols = 50,
  nlevels = 50,
  drawlabels = FALSE,
  expand = 1,
  pipe = TRUE,
  lwd = 1,
  lty = 1,
  ...
)
}
\arguments{
\item{mspace}{An \code{"mspace"} object.}

\item{FUN}{A function to be applied to an array of shapes (the background models) along
its third margin, and returning a single numeric value from each. These values will
be interpolated to generate the landscape surface.}

\item{X}{A vector containing the values assigned to each background shape model (vector
length must match the number of the shape models in the background and have the order).}

\item{method}{Method used for interpolation. For now, the only option available is
\code{"interp"}, which calls the function \code{\link[akima:interp]{akima::interp()}}.}

\item{palette}{Color palette to use for landscape representation.}

\item{ncols}{Number of colors to use for landscape representation.}

\item{nlevels}{Number of levels (i.e. contours) to use in landscape representation.}

\item{drawlabels}{Logical; should the labels indicating the value of each surface contour be plotted?}

\item{expand}{Numeric; Magnification factor to extend (adjust) the reach of the landscape.}

\item{pipe}{Logical; is the function being included in a pipe?}

\item{lwd}{Numeric; width of the lines depicting surface contour.}

\item{lty}{Numeric; type of the lines depicting surface contour.}

\item{...}{Further arguments passed to \code{FUN}.}
}
\value{
If a plot device with a morphospace is open, the landscape surface is projected
into it as a contour map using \code{\link[akima:interp]{akima::interp()}}. If \code{pipe = FALSE}, a list of
length 3 containing the x, y and z values used to plot the landscape is returned invisibly.
If \code{pipe = TRUE} the supplied \code{"mspace"} object will be modified by adding a new
\code{$landsc} slot together with a number of graphical parameters (stored into the
\code{$plotinfo} slot), and returned invisibly.
}
\description{
Compute and project a landscape surface over an existing morphospace.
Experimental.
}
\details{
The purpose of this function is to generate and depict a 3-dimensonal surface
(i.e. a landscape), interpolated from values assigned to the set of background shape models
of an existing morphospace created using \code{mspace}. Generally, these values will
represent a variable measuring functional performance (although it can be any kind of
continuous variable), and can either be provided directly through the \code{X} argument
or be computed automatically using an ad hoc R function through the \code{FUN} argument.

If the \code{FUN} argument is used, the function provided must include a \code{model} argument
feeding the ad hoc function with a single shape, and return a single numeric value computed
for (or from) that shape. If the \code{X} argument is used instead, values should be provided
in the same order than the background shape models are plotted (i.e. from left to right and from
bottom to top; see \code{\link{morphogrid}}, \code{\link{plot_morphogrid2d}} and
\code{\link{plot_morphogrid3d}}). See examples below.
}
\examples{
#load data and packages
library(geomorph)
library(Morpho)
library(Momocs)

data("tails")
shapes <- tails$shapes
links <- tails$links


#Compute and plot adaptive landscape for wing tail shape:

##Using the FUN argument

#a function to compute lift/drag ratio on tail shape:
computeLD <- function(model, MCS = FALSE) {

  tail <- model
  Ax <- tail[9, 1] ; Ay <- tail[9, 2]
  Bx <- tail[5, 1] ; By <- tail[5, 2]
  X <- tail[7, 1] ; Y <- tail[7, 2]

  # determine position of the tip of the inner rectrix relative to the tips of
  # the outermost rectrices (positive: anterior to the ORT; negative: posterior
  # to the ORT)
  tip_pos1 <- sign((Bx - Ax) * (Y - Ay) - (By - Ay) * (X - Ax))

  # do the same but for the inner outer rectrices
  Ax <- tail[8, 1] ; Ay <- tail[8, 2]
  Bx <- tail[6, 1] ; By <- tail[6, 2]
  X <- tail[7, 1] ; Y <- tail[7, 2]

  # determine position of the tip of the inner rectrix relative to the tips of
  # the outermost rectrices (positive: anterior to the ORT; negative: posterior
  # to the ORT)
  tip_pos2 <- sign((Bx - Ax) * (Y - Ay) - (By - Ay) * (X - Ax))

  # compute the area of the polygon representing the whole tail
  tail_area <- coo_area(tail[c(1, 3, 5, 6, 7, 8, 9, 4, 2, 1), ])


  # if posterior, compute MCS as the distance between the ORTs, and the lifting
  # area as the polygon enclosed by the ORTs and tail base
  if(tip_pos1 == -1) {
    mcs <- dist(rbind(tail[5, ], tail[9, ]))
    lifting_area <- coo_area(tail[c(1, 3, 5, 9, 4, 2, 1),])
  }

  # if anterior, find the maximum continuous span as the line perpendicular to
  # the saggital axis that intersects the ORTs and the IRT
  if(tip_pos1 == 1 & tip_pos2 == 1) {

    # center tail around the IRT and set MCS as a vertical line passing through
    # the origin
    tail_cent <- cbind(tail[, 1] - tail[7, 1],
                       tail[, 2] - tail[7, 2])
    mcs_vec <- c(0,10e10)

    ort1 <- rbind(tail_cent[4, ], tail_cent[9, ])
    ort1_vec <- lm(ort1[, 2] ~ ort1[, 1])$coef

    ort2 <- rbind(tail_cent[3, ], tail_cent[5, ])
    ort2_vec <- lm(ort2[, 2] ~ ort2[, 1])$coef

    # find tips of MCS
    A <- matrix(c(mcs_vec[2], -1, ort1_vec[2], -1), byrow = TRUE, nrow = 2)
    b <- c(-mcs_vec[1], -ort1_vec[1])
    p1 <- solve(A, b)

    A <- matrix(c(mcs_vec[2], -1, ort2_vec[2], -1), byrow = TRUE, nrow = 2)
    b <- c(-mcs_vec[1], -ort2_vec[1])
    p2 <- solve(A, b)

    # define "new tail base", enclosing the polygon using the tips of the MCS
    newbase <- rbind(tail_cent[c(2, 4), ],
                     p1,
                     tail_cent[7, ],
                     p2,
                     tail_cent[c(3, 1), ])

    # compute MCS and lifting area
    lifting_area <- coo_area(newbase[c(1, 2, 3, 4, 5, 6, 7, 1),])
    mcs <- dist(rbind(p1, p2))

  }

  # if anterior, find the maximum continuous span as the line perpendicular to
  # the saggital axis that intersects the ORTs and the IRT
  if(tip_pos1 == 1 & tip_pos2 == -1) {

    # center tail around the IRT and set MCS as a vertical line passing through
    # the origin
    tail_cent <- cbind(tail[, 1] - mean(tail[6, 1], tail[8, 1]),
                       tail[, 2] - mean(tail[6, 2], tail[8, 2]))
    mcs_vec <- c(0,10e10)

    ort1 <- rbind(tail_cent[4, ], tail_cent[9, ])
    ort1_vec <- lm(ort1[, 2] ~ ort1[, 1])$coef

    ort2 <- rbind(tail_cent[3, ], tail_cent[5, ])
    ort2_vec <- lm(ort2[, 2] ~ ort2[, 1])$coef

    # find tips of MCS
    A <- matrix(c(mcs_vec[2], -1, ort1_vec[2], -1), byrow = TRUE, nrow = 2)
    b <- c(-mcs_vec[1], -ort1_vec[1])
    p1 <- solve(A, b)

    A <- matrix(c(mcs_vec[2], -1, ort2_vec[2], -1), byrow = TRUE, nrow = 2)
    b <- c(-mcs_vec[1], -ort2_vec[1])
    p2 <- solve(A, b)

    # define "new tail base", enclosing the polygon using the tips of the MCS
    newbase <- rbind(tail_cent[c(2, 4), ],
                     p1,
                     tail_cent[7, ],
                     p2,
                     tail_cent[c(3, 1), ])

    # compute MCS and lifting area
    lifting_area <- coo_area(newbase[c(1, 2, 3, 4, 5, 6, 7, 1),])
    mcs <- dist(rbind(p1, p2))

  }

  #compute and return lift/drag ratio
  if(!MCS) LD_ratio <- lifting_area / tail_area
  if(MCS)  LD_ratio <- (mcs ^ 2) / tail_area

  return(as.numeric(LD_ratio))

}

#plot morphospace with its associated adaptive landscape
mspace(shapes, links = links, nh = 8, nv = 8, size.model = 1.5, cex.ldm = 0) \%>\%
  proj_shapes(shapes, pch = 16) \%>\%
  proj_landscape(nlevels = 60, ncols = 60, FUN = computeLD, expand = 1.2)


##Using the X argument

#first, create morphospace and extract background shapes
msp <- mspace(shapes, links = links, nh = 8, nv = 8, size.model = 1.5, cex.ldm = 0)
shapemodels <- msp$plotinfo$shapemodels$models_arr

#run computeLD (defined above) through the array of shapes models (this is the
#same thing the proj_landscape function is doing internally when FUN is used, but
#this vector could be replaced with some other variable obtained in a different way)
LDs <- apply(X = shapemodels, FUN = computeLD, MARGIN = 3)

#plot morphospace with its associated adaptive landscape
mspace(shapes, links = links, nh = 8, nv = 8, size.model = 1.5, cex.ldm = 0) \%>\%
  proj_shapes(shapes, pch = 16) \%>\%
  proj_landscape(nlevels = 60, ncols = 60, X = LDs, expand = 1.2)
}
