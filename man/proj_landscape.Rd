% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mspace_workflow.R
\name{proj_landscape}
\alias{proj_landscape}
\title{Project landscape into morphospace}
\usage{
proj_landscape(
  mspace,
  FUN = NULL,
  X = NULL,
  method = "spline",
  palette = heat.colors,
  ncols = 50,
  nlevels = 50,
  drawlabels = FALSE,
  expand = 1,
  lwd = 1,
  lty = 1,
  pipe = TRUE,
  ...
)
}
\arguments{
\item{mspace}{An \code{"mspace"} object.}

\item{FUN}{A function to be applied to an array of shapes (the background models) along
its third margin, and returning a single numeric value from each. These values will
be interpolated to generate the landscape surface.}

\item{X}{A vector containing the values assigned to each background shape model (vector
length must match the number of the shape models in the background and have the order).}

\item{method}{Method used for interpolation; either \code{"linear"} or \code{"spline"}.
See \code{\link[akima:interp]{akima::interp()}}.}

\item{palette}{Color palette to use for landscape representation.}

\item{ncols}{Number of colors to use for landscape representation.}

\item{nlevels}{Number of levels (i.e. contours) to use in landscape representation.}

\item{drawlabels}{Logical; should the labels indicating the value of each surface contour be plotted?}

\item{expand}{Numeric; Magnification factor to extend (adjust) the reach of the landscape,
attained by extrapolating the x, y, and z values. Only available for \code{method = "spline"}.}

\item{lwd}{Numeric; width of the lines depicting surface contour.}

\item{lty}{Numeric; type of the lines depicting surface contour.}

\item{pipe}{Logical; is the function being included in a pipe?}

\item{...}{Further arguments passed to \code{FUN}.}
}
\value{
If a plot device with a morphospace is open, the landscape surface is projected
into it as a contour map using \code{\link[akima:interp]{akima::interp()}}. If \code{pipe = FALSE}, a list containing
the x, y and z values used to plot the landscape (x and z for univariate morphospaces) is
returned invisibly. If \code{pipe = TRUE} the supplied \code{"mspace"} object will be modified
by adding a new \code{$landsc} slot together with a number of graphical parameters (stored into
the \code{$plotinfo} slot), and returned invisibly.
}
\description{
Compute and/or project a landscape surface over an existing morphospace.
Experimental.
}
\details{
The purpose of this function is to generate and depict a 2- (for univariate morphospaces)
or 3-dimensonal (for bivariate morphospaces) surface (i.e. a landscape), interpolated from values
assigned to the set of background shape models of an existing morphospace created using
\code{\link{mspace}}. Generally, these values will represent a variable measuring functional
performance (although it can be any kind of continuous variable), and can be either provided
directly through the \code{X} argument in a two-steps procedure or computed automatically using
an \emph{ad hoc} function through the \code{FUN} argument.

If the \code{FUN} argument is used, the function provided must include a \code{model}
argument feeding the \emph{ad hoc} function with a single shape, and return a single numeric
value computed for or from that shape. If the \code{X} argument is used instead, values
should be provided in the same order than the background shape models are plotted (i.e. from
left to right and from bottom to top; see \code{\link{morphogrid}}, \code{\link{plot_morphogrid2d}}
and \code{\link{plot_morphogrid3d}}). The latter alternative can be useful when importing
variables from other software or pipelines, but the background shape models used to compute the
vector feeding \code{X} in the first step must the same used to depict the morphospace in the
second step (otherwise, the shapes in the background won't match the landscape surface projected
over them). See examples below.

Because the landscape surface is generated for a specific set of background shape models,
regenerating the former using \code{\link{plot_mspace}} is only possible if the new axes being
depicted are the same than those used for computing the surface landscape originally through
\code{\link{mspace}} + \code{\link{proj_landscape}}. The only exception is when one of the original
axes is dropped, which will result in a the collapse of the 3D landscape projected into a bivariate
morphospace into a 2D landscape projected into a univariate one.
}
\examples{
#load data and packages
library(geomorph)
library(Morpho)
library(Momocs)

data("tails")
shapes <- tails$shapes
links <- tails$links


#Compute and plot adaptive landscape for wing tail shape:

##Using the FUN argument

#a function to compute lift/drag ratio on tail shape:
computeLD <- function(model, MCS = FALSE) {

  tail <- model
  Ax <- tail[9, 1] ; Ay <- tail[9, 2]
  Bx <- tail[5, 1] ; By <- tail[5, 2]
  X <- tail[7, 1] ; Y <- tail[7, 2]

  # determine position of the tip of the inner rectrix relative to the tips of
  # the outermost rectrices (positive: anterior to the ORT; negative: posterior
  # to the ORT)
  tip_pos1 <- sign((Bx - Ax) * (Y - Ay) - (By - Ay) * (X - Ax))

  # do the same but for the inner outer rectrices
  Ax <- tail[8, 1] ; Ay <- tail[8, 2]
  Bx <- tail[6, 1] ; By <- tail[6, 2]
  X <- tail[7, 1] ; Y <- tail[7, 2]

  # determine position of the tip of the inner rectrix relative to the tips of
  # the outermost rectrices (positive: anterior to the ORT; negative: posterior
  # to the ORT)
  tip_pos2 <- sign((Bx - Ax) * (Y - Ay) - (By - Ay) * (X - Ax))

  # compute the area of the polygon representing the whole tail
  tail_area <- coo_area(tail[c(1, 3, 5, 6, 7, 8, 9, 4, 2, 1), ])


  # if posterior, compute MCS as the distance between the ORTs, and the lifting
  # area as the polygon enclosed by the ORTs and tail base
  if(tip_pos1 == -1) {
    mcs <- dist(rbind(tail[5, ], tail[9, ]))
    lifting_area <- coo_area(tail[c(1, 3, 5, 9, 4, 2, 1),])
  }

  # if anterior, find the maximum continuous span as the line perpendicular to
  # the saggital axis that intersects the ORTs and the IRT
  if(tip_pos1 == 1 & tip_pos2 == 1) {

    # center tail around the IRT and set MCS as a vertical line passing through
    # the origin
    tail_cent <- cbind(tail[, 1] - tail[7, 1],
                       tail[, 2] - tail[7, 2])
    mcs_vec <- c(0,10e10)

    ort1 <- rbind(tail_cent[4, ], tail_cent[9, ])
    ort1_vec <- lm(ort1[, 2] ~ ort1[, 1])$coef

    ort2 <- rbind(tail_cent[3, ], tail_cent[5, ])
    ort2_vec <- lm(ort2[, 2] ~ ort2[, 1])$coef

    # find tips of MCS
    A <- matrix(c(mcs_vec[2], -1, ort1_vec[2], -1), byrow = TRUE, nrow = 2)
    b <- c(-mcs_vec[1], -ort1_vec[1])
    p1 <- solve(A, b)

    A <- matrix(c(mcs_vec[2], -1, ort2_vec[2], -1), byrow = TRUE, nrow = 2)
    b <- c(-mcs_vec[1], -ort2_vec[1])
    p2 <- solve(A, b)

    # define "new tail base", enclosing the polygon using the tips of the MCS
    newbase <- rbind(tail_cent[c(2, 4), ],
                     p1,
                     tail_cent[7, ],
                     p2,
                     tail_cent[c(3, 1), ])

    # compute MCS and lifting area
    lifting_area <- coo_area(newbase[c(1, 2, 3, 4, 5, 6, 7, 1),])
    mcs <- dist(rbind(p1, p2))

  }

  # if anterior, find the maximum continuous span as the line perpendicular to
  # the saggital axis that intersects the ORTs and the IRT
  if(tip_pos1 == 1 & tip_pos2 == -1) {

    # center tail around the IRT and set MCS as a vertical line passing through
    # the origin
    tail_cent <- cbind(tail[, 1] - mean(tail[6, 1], tail[8, 1]),
                       tail[, 2] - mean(tail[6, 2], tail[8, 2]))
    mcs_vec <- c(0,10e10)

    ort1 <- rbind(tail_cent[4, ], tail_cent[9, ])
    ort1_vec <- lm(ort1[, 2] ~ ort1[, 1])$coef

    ort2 <- rbind(tail_cent[3, ], tail_cent[5, ])
    ort2_vec <- lm(ort2[, 2] ~ ort2[, 1])$coef

    # find tips of MCS
    A <- matrix(c(mcs_vec[2], -1, ort1_vec[2], -1), byrow = TRUE, nrow = 2)
    b <- c(-mcs_vec[1], -ort1_vec[1])
    p1 <- solve(A, b)

    A <- matrix(c(mcs_vec[2], -1, ort2_vec[2], -1), byrow = TRUE, nrow = 2)
    b <- c(-mcs_vec[1], -ort2_vec[1])
    p2 <- solve(A, b)

    # define "new tail base", enclosing the polygon using the tips of the MCS
    newbase <- rbind(tail_cent[c(2, 4), ],
                     p1,
                     tail_cent[7, ],
                     p2,
                     tail_cent[c(3, 1), ])

    # compute MCS and lifting area
    lifting_area <- coo_area(newbase[c(1, 2, 3, 4, 5, 6, 7, 1),])
    mcs <- dist(rbind(p1, p2))

  }

  #compute and return lift/drag ratio
  if(!MCS) LD_ratio <- lifting_area / tail_area
  if(MCS)  LD_ratio <- (mcs ^ 2) / tail_area

  return(as.numeric(LD_ratio))

}

#plot morphospace with its associated adaptive landscape
mspace(shapes, links = links, nh = 8, nv = 8, size.model = 1.5, cex.ldm = 0) \%>\%
  proj_shapes(shapes, pch = 16) \%>\%
  proj_landscape(nlevels = 60, ncols = 60, FUN = computeLD, expand = 1.2)


##Using the X argument

#first, create morphospace and extract background shapes
msp <- mspace(shapes, links = links, nh = 8, nv = 8, size.model = 1.5, cex.ldm = 0)
shapemodels <- msp$plotinfo$shapemodels$models_arr

#run computeLD (defined above) through the array of shapes models (this is the
#same thing the proj_landscape function is doing internally when FUN is used, but
#this vector could be replaced with some other variable obtained in a different way)
LDs <- apply(X = shapemodels, FUN = computeLD, MARGIN = 3)

#second, plot morphospace with its associated adaptive landscape
mspace(shapes, links = links, nh = 8, nv = 8, size.model = 1.5, cex.ldm = 0) \%>\%
  proj_shapes(shapes, pch = 16) \%>\%
  proj_landscape(nlevels = 60, ncols = 60, X = LDs, expand = 1.2)

#be careful to use the same morphospaces in the second and first steps.
#For example, retaining the LD values computed above but changing the axes
#represented by mspace will result in the same surface wrongly being projected
#over a different morphospace!
mspace(shapes, links = links, nh = 8, nv = 8, size.model = 1.5, cex.ldm = 0, axes = c(2,3)) \%>\%
  proj_shapes(shapes, pch = 16) \%>\%
  proj_landscape(nlevels = 60, ncols = 60, X = LDs, expand = 1.2)
}
\seealso{
\code{\link{morphogrid}}, \code{\link{mspace}}, \code{\link{plot_morphogrid2d}},
\code{\link{plot_morphogrid3d}}
}
